ORM и Модели
===

[<< документация](readme.md)

ORM — объектно-реляционное отображение.

[http://ru.wikipedia.org/wiki/ORM](http://ru.wikipedia.org/wiki/ORM)

[http://en.wikipedia.org/wiki/Object-relational_mapping](http://en.wikipedia.org/wiki/Object-relational_mapping)

## DVelum ORM

ORM ответственно за хранение данных, описывает их структуру, валидирует для вставки и обновления.

Мы постарались максимально снизить ограничения, которые обычно накладывает ORM, осталось только два:

* запись данных должна происходить через объекты ORM (иначе могут возникнуть проблемы целостности данных);
* для извлечения связей “многие ко многим” необходимо сверяться с линковочной таблицей.

ORM не содержит инструментария выборки списков объектов и цепочек взаимосвязей.

Концепция работы с БД схожа с концепцией [CQRS](https://ru.wikipedia.org/wiki/CQRS):
* сохраняем и валидируем данные через Orm\Record (т.е. через объекты ORM)
* получаем списки, а так же сложные выборки через Model (модели и конструкторы запросов)

При сохранении данных, кроме валидации данных происходит инвалидация кэша и запуск классов триггеров.

ORM умеет автоматичеки синхронизировать структуру таблиц базы данных, работат сразу с несколькими серверами БД, работать с шардингом.
Нет необходимости писать миграции, система сделает это сама по команде.

Схема данных описывается при помощи интерфейса управления, храница в файлах конфигурации в системе контроля версий.

Интерфей управления ORM кроме всего прочего позволяет следить за состоянием таблиц и индексов, строить UML диаграмы, редактировать данные.
 
 

Модели инстанцируются методом 
```php Model::factory('ObjectName') ``` 
и бывают двух видов:

* виртуальные — если вы не определяли дополнительной логики модели, фабрика моделей вернет вам ссылку на объект, содержащий набор стандартных методов выборки данных;
* расширенные — используются в том случае, если вам необходимо расширить логику выборок, придставляют из себя класс наследник базовой модели.

Расширенные модели — в папку application\classes\App\Model добавляется файл классом аналогичным названию 
объекта в ORM, при этом "_" в название объекта  - это вложенность дирректории.
Сам класс должен быть отнаследован от Dvelum\Orm\Model, в нем вы описываете дополнительную логику работы с данными объектов,
 например, дополнительные методы по выборке данных с определенными параметрами и условиями 
 (Factory автоматически подхватит этот класс и вернет Вам ссылку на его объект).


В ORM кроме стандартных полей есть ссылки:

* на объекты  (один ко многим) - в качестве данных принимают id-идентификатор объекта;
* на списки объектов (многие ко многим) - в качестве данных принимают массив id-идентификаторов объекта; Связи объектов могут быть полиморфные, либо через таблицу линковки
* ссылки на словари - в качестве данных принимают ключ словаря.


Для объектов ORM  и моделей может быть индивидуально переопределено подключение к базе данных, 
что позволяет рассредоточить данные по нескольким серверам баз данных.

Обратите внимание, что при изменении структуры объектов перевалидация существующих данных не производится, 
это может привести к неблагоприятным последствиям.


Поскольку DVelum - это в первую очередь среда разработки, вы можете действовать, как считаете нужным, мы лишь стараемся 
упростить работу. Специально спроектировали ORM так, чтобы было как можно меньше проблем с прямыми выборками.

### Пример работы:

Создаем объект ORM с именем  "my_object" в [интерфейсе управления ORM](orm_main.md)

```php
<?php
use Dvelum\Orm\Record;
use Dvelum\Orm\Model;
use Dvelum\Db\Select\Filter;

// Инстанцируем модель "my_object"
$myObjectModel = Model::factory('my_object');

// Создаем новый объект ORM типа "my_object"
$myObject = Record::factory('my_object');

try{
    // задаем значения свойств, может бросить исключение валидации
    $myObject->setValues([
        'prop1' => 'val1',
        'prop2' => 'val2',
    ]);
    // сохраняем запись, может вернуть  false  при ошибке
    if(!$myObject->save()){
        throw new Exception('Cannot save my_object '.$myObject->getErrors());
    }   
}catch (\Exception $e){
    // логируем ошибку (системная таблица ошибок)
    $myObjectModel->logError($e->getMessage());
    
}

// пример получения выборки данных с ипользованием упрощенного конструктора запросов
$query = $myObjectModel->query()
                        // список полей, которые нам нужны
                       ->fields(['id','prop1','prop2'])
                        // дополнительные фильтры данных
                       ->filters([
                          // где значение в колонке prop1 равно val1
                          'prop1' => 'val1',
                          // пример более сложного фильтра  
                           new Filter(
                                // колонка
                               'prop2',
                                // значение
                                ['v1','v2','v3'],
                                // тип фильтра
                                Filter::NOT_IN
                            )
                       ])
                       ->params([
                           'sort'=>'name',
                           'dir'=>'DESC',
                           'start'=>0,
                           'limit'=>10
                       ]);
// узнать кол-во строк подходящих под условия фильтрации в запросе
$rowsCount = $query->getCount();
// получить данные
$rows = $query->fetchAll();

```